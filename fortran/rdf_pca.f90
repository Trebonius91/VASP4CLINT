!
!    rdf_pca: evaluates a given radial distribution function
!      (time-dependent or time-independent). It compares the RDF
!      to a list of given reference RDFs of known phases such 
!      that the weight of different components can be obtained
!    Part of VASP4CLINT 
!     Julien Steffen, 2023 (julien.steffen@fau.de)
!

module rdf_mod
implicit none
real(kind=8),allocatable::rdf_ana(:,:),rdf_ref(:,:)
integer::frame_act
end module rdf_mod

program rdf_pca
use rdf_mod
implicit none
integer::i,j,k,l,m,q
integer::readstat
integer::nstarts,nframes
integer::nlines,nlines2,idum,nlines_old
real(kind=8)::adum
character(len=100)::arg
character(len=2)::indname
character(len=100)::ana_filename,cdum
character(len=100)::ref_filename(99)
logical::ref_read(99),count_lines
real(kind=8),allocatable::weights(:),deriv(:)
real(kind=8),allocatable::weights_best(:)
real(kind=8),allocatable::x_vals(:)
real(kind=8)::err_sum,sum1
real(kind=8)::err_sum_best,err_sum_best2
real(kind=8),allocatable::fvec(:),rdf_approx(:)
real(kind=8),allocatable::fvec_best(:)
real(kind=8),allocatable::rdf_weight(:,:)
real(kind=8)::tol
real(kind=8),allocatable::err_best(:)
real(kind=8),allocatable::weigh_best(:,:)
integer::iwa,lwa,info
integer::iind,jind,p
integer::msls_starts
real(kind=8),allocatable::wa(:)
integer::ref_num,ref_num_old
external::error_function

write(*,*)
write(*,*) "PROGRAM rdf_pca: Evaluation of time-independent and"
write(*,*) " time-dependent radial distribution functions by looking"
write(*,*) " after principial RDF components given by files."
write(*,*) "The program needs an RDF profile to be analyzed, and a list"
write(*,*) " of at least two reference RDFs from which the RDF of "
write(*,*) " interest shall be built."
write(*,*) "All RDF profiles need to be generated by td_rdf.dat, they "
write(*,*) " need to have three coulumns: frame.No, x-value,RDF-value"
write(*,*) "All RDFs must have the same x-axis and the same No. of points"
write(*,*) "Filenames need to be given by the following keywords:"
write(*,*) " -rdf_file=[filename] : The analyzed RDF profile"
write(*,*) " -ref1=[filename1] -rdf2=[filename2] ... : The reference RDFs"
write(*,*) "Further, the number of multi start local search (MSLS) starts "
write(*,*) " can be given (default value: 100): -msls_starts=[number]"
write(*,*) 


!
!    Default number of starts for the multistart local search
!
msls_starts=100
!
!    Read in and process the command line arguments
!
!    The RDF to be analyzed
!
ana_filename="xxx"
do i = 1, command_argument_count()
   call get_command_argument(i, arg)
   if (trim(arg(1:10))  .eq. "-rdf_file=") then
      read(arg(11:),*,iostat=readstat) ana_filename
   end if
end do

if (ana_filename .eq. "xxx") then
   write(*,*) "Please give the filename of the DOS file to be analyzed!"
   stop
end if

!
!    The list of reference DOS profiles (up to 99)
!    Read in a number of keywors in the form -ref[num]=... from 1 to 99
!    until the first keyword does not appear anymore. Then i-1 is 
!    the total number of given reference curves
!
ref_read=.false.
ref_num=0
do i=1,99
   if (i .lt. 10) then
      write(indname,'(i1)') i
      do j = 1, command_argument_count()
         call get_command_argument(j, arg)
         if (trim(arg(1:6))  .eq. "-ref"//trim(indname)//"=") then      
            read(arg(7:),*,iostat=readstat) ref_filename(i)
            ref_read(i) = .true.
            ref_num=ref_num+1
         end if
      end do
   else 
      write(indname,'(i2)') i
      do j = 1, command_argument_count()
         call get_command_argument(j, arg)
         if (trim(arg(1:7))  .eq. "-ref"//trim(indname)//"=") then  
            read(arg(8:),*,iostat=readstat) ref_filename(i)
            ref_read(i) = .true.
            ref_num=ref_num+1
         end if
      end do
   end if
   if (.not. ref_read(i)) exit
end do

do i = 1, command_argument_count()
   call get_command_argument(i, arg)
   if (trim(arg(1:13))  .eq. "-msls_starts=") then
      read(arg(14:),*,iostat=readstat) msls_starts
   end if
end do


if (ref_num .lt. 2) then
   write(*,*) "Please give at last two reference RDF profiles!"
   stop
end if
write(*,*) " - Analyzed RDF profile:  ",ana_filename
do i=1,ref_num
   write(*,'(a,i2,a,a)') "  - Reference No. ",i,":      ",ref_filename(i)
end do

!
!    Now read in the analyzed RDF profile
!
!    First determine the number of lines per frame
!
!    Time-dependent profiles can also be analyzed! 
!    In this case, count the number of frames as well
!
nlines=0
nlines2=0
open(unit=34,file=ana_filename,status="old",iostat=readstat)
if (readstat .ne. 0) then
   write(*,*) "The file with the analyzed RDF profile (",trim(ana_filename),") is not there!"
   stop 
end if
count_lines=.true.
do
   adum=1D17
   read(34,'(a)',iostat=readstat) cdum
   if (len(trim(cdum)) .lt. 5) then
      count_lines = .false.
      read(34,*,iostat=readstat) idum,adum,adum
      if (readstat .ne. 0) exit   
   end if
   if (count_lines) then
      nlines=nlines+1
   end if
   nlines2=nlines2+1
end do
nframes=int(nlines2/(nlines+1))


close(34)


write(*,'(a,i10)')  "  - Number of starts in the MSLS algorithm: ",msls_starts
write(*,'(a,i10)')  "  - Number of plot points in RDFs: ",nlines
write(*,'(a,i10)')  "  - Number of RDF time frames: ",nframes
write(*,*)

allocate(x_vals(nlines))
allocate(rdf_ana(nlines,nframes))
allocate(rdf_ref(nlines,ref_num))
!
!    Read in the analyzed RDF profile
!
open(unit=34,file=ana_filename,status="old")
do i=1,nframes
   do j=1,nlines
      read(34,*) idum,x_vals(j),rdf_ana(j,i)
   end do
end do
close(34)

!
!     Read in the principial component RDF curves
!
do i=1,ref_num
   open(unit=35,file=ref_filename(i),status="old",iostat=readstat)
   if (readstat .ne. 0) then
      write(*,*) "The reference RDF curve No. ",i," in ",trim(ref_filename(i))," is not there!"
      stop 
   end if
   do j=1,nlines
      read(35,*) idum,adum,rdf_ref(j,i)
   end do
   close(35)
end do

!
!     now perform the multi start local search optimization of 
!     principial component weights
!
allocate(weights(ref_num))
allocate(deriv(ref_num))
allocate(fvec(nlines))
allocate(fvec_best(nlines))
allocate(weights_best(ref_num))
allocate(rdf_approx(nlines))
allocate(rdf_weight(nlines,ref_num))
allocate(weigh_best(ref_num,nframes))
allocate(err_best(nframes))
iwa=ref_num
lwa=nlines*ref_num+5*ref_num+nlines+1000
allocate(wa(lwa))
tol=1E-4

write(*,*) "Do the Levenberg-Marquardt fit ...."
err_sum_best2=1000000d0
err_best=1000000d0
weigh_best=1.0d0
do q=1,nframes
   frame_act=q
   do p=1,msls_starts
      iwa=ref_num
      lwa=nlines*ref_num+5*ref_num+nlines+1000
      tol=1E-4
!
!     Random initialize weights (sum needs not to be 1 always)
!
!     Function seems to be convex! First, equal weight for each phase, sum 
!      shall be 1
!
      do jind=1,ref_num
         call random_number(weights(jind))
         weights(jind)=weights(jind)!*5d0
      end do

!
!     Perform the Levenberg Maraquardt optimization starting with the 
!      current random weights
!
!   call r8vec_print (ref_num, weights, '  Initial parameter values:' )
      call lmdif1(error_function,nlines,ref_num,weights,fvec,tol,info,iwa,wa,lwa)
!   
!     Calculate error sum for current coordinate vector
!
!   call r8vec_print (ref_num, weights, '  Optimized parameter values:' )
      err_sum=0.d0
      do jind=1,nlines
         err_sum=err_sum+fvec(jind)**2
      end do
!
!     If better local minimum has been found, store its values for global minimum
!
      if (err_sum .lt. err_best(1)) then
         write(*,'(a,i6,a,f17.10)') " STEP ",p,": New best error sum: ",err_sum
         err_best(q)=err_sum
         weigh_best(:,q)=weights        
      end if
   end do
end do

write(*,*) " ... done!"
write(*,*) " Error sum of the fit (final frame): ",err_best(nframes)

!
!     Calculate the weighted reference curves
!
do i=1,nlines
   do j=1,ref_num
      rdf_weight(i,j)=rdf_ref(i,j)*weigh_best(j,nframes)
   end do
end do
!
!     Write the final approximated curve (and the single components) 
!      together with the true RDF curve that shall be aapproximated
!
rdf_approx=0.d0
do i=1,nlines
   do j=1,ref_num
      rdf_approx(i)=rdf_approx(i)+rdf_weight(i,j)
   end do
end do
write(*,*)
write(*,*) "Fitted curve as well as optimized components (last frame) written to "
write(*,*) " file 'rdf_approx.dat'"
open(unit=48,file="rdf_approx.dat",status="replace")
write(48,*) "# dist (Angs)     true RDF     approximated RDF      component 1-i ..."
do i=1,nlines
   write(48,*) x_vals(i),rdf_ana(i,nframes),rdf_approx(i),rdf_weight(i,:)
end do
close(48)
!
!    Normalize the weights such that its sum is one for the output
!
do j=1,nframes
   do i=1,ref_num
      if (weigh_best(i,j) .lt. 0.d0) then
         weigh_best(i,j) = 0.d0
      end if 
   end do
   weigh_best(:,j)=weigh_best(:,j)/sum(weigh_best(:,j))
end do
write(*,*) 
write(*,*) "Final weights of the different given reference RDFs (last frame):"
do i=1,ref_num
   write(*,'(a,i2,a,a,a,f13.7)') "  - Reference No. ",i,":      ", &
       & ref_filename(i)(1:30),": ",weigh_best(i,nframes)
end do
open(unit=45,file="final_weights.dat",status="replace")
write(45,*) "#  RDF frame    weights of components"
do i=1,nframes
   write(45,*) i,weigh_best(:,i)
end do
close(45)
write(*,*) "Final weights written to 'final_weights.dat'."

write(*,*)
write(*,*) "Program rdf_pca terminated normally."
write(*,*)


end program rdf_pca


subroutine error_function(m_ind,n_ind,x_var,fvec,iflag)
use rdf_mod
implicit none
integer::m_ind,n_ind
real(kind=8)::fvec(m_ind)
real(kind=8)::x_var(n_ind)
integer::i2,j2,iflag
real(kind=8)::sum1

do i2=1,m_ind
   sum1=0.d0
   do j2=1,n_ind
      sum1=sum1+rdf_ref(i2,j2)*x_var(j2)
   end do
   fvec(i2)=rdf_ana(i2,frame_act)-sum1  
end do
!
!    Add a penalty for each negative parameter
! 
do j2=1,n_ind
   if (x_var(j2) .lt. 0.d0) then
      fvec=fvec+x_var(j2)**2*1D6
   end if
end do

return
end subroutine error_function
